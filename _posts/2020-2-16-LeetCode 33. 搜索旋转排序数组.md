---
title: 2020-2-16-LeetCode 33. 搜索旋转排序数组
date: 2020-2-16
permalink: /posts/2020/2/16/blog-post-1/ 
tags: 
- 算法笔记
- LeetCode
- 数据结构
renderNumberedHeading: true
grammar_cjkRuby: true
---

# 1. 题目
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 **O(log n)** 级别。
>
> **示例 1:**
> 
>输入: nums = [4,5,6,7,0,1,2], target = 0
>输出: 4

>**示例 2:**
>
>输入: nums = [4,5,6,7,0,1,2], target = 3
>输出: -1

# 2. 题解
参照题解：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-bai-liao-9983de-javayong-hu-by-reedfan/

首先看到这个题目，部分有序数组的查找，题目要求的复杂度，基本确定是二分查找了，但问题关键在于，怎么确定二分的点。

这种旋转排序数组，大致可分为两类：
例如：`1234567`
- 前半部分有序，即 `nums[start] <= nums[mid]`， 如 `3456712`。
	这种情况下，如果目标在有序的部分中，即`nums[start] <= target < nums[mid]`，就在前半段找，否则就去后半段找；
- 后半部分有序，即 `nums[start] > nums[mid]`，如 `6712345`。
	这种情况下，如果目标在有序的部分中，即`nums[mid] <= target < nums[end]`，就在后半段找，否则就去前半段找。
	
# 3. Java实现
```java
import java.util.Scanner;

class Solution01 {
	public int search(int[] nums, int target) {
        if(nums == null || nums.length == 0){
        	return -1;
        }
        int start = 0, end = nums.length-1;
        int mid;
        while (start <= end){
        	mid = start + (end - start) / 2;//二分法计算mid数值
        	if (nums[mid] == target){//查找的出口。
        		return mid;
        	}
        	if(nums[start] <= nums[mid]){//当数组第一个元素小于中间元素，则为前半段有序
        		if(target >= nums[start] && target < nums[mid]){//如果要查找的值在有序的部分 即前半部分
        			end = mid - 1;//向前二分查找， 缩小查找范围
        		} else {
        			start = mid + 1;//否则，目标值不在有序的范围，即前半段，则向后二分查找，缩小查找范围
        		}
        	} else {//否则为数组后半段有序
        		if(target <= nums[end] && target > nums[mid]){//如果目标值在有序部分，即后半段
        			start = mid + 1;//向后二分查找，缩小查找范围
        		} else {
        			end = mid - 1;
        		}
        	}
        }
        return -1;//如果所有查找结束 都没有找到，返回-1
    }
	//test case
    public static void main(String[] args){
    Solution01 test=new Solution01();
    System.out.println("input array split by , :");
    Scanner sc = new Scanner(System.in);
    String str = sc.next().toString();
    String[] arr = str.split(",");
    int[] num = new int[arr.length];
    for(int i=0;i<num.length;i++){
    	num[i] = Integer.parseInt(arr[i]);
    }
    System.out.println("input target number :");
    int target = Integer.parseInt(sc.next().toString());
    
    int result = test.search(num, target);
    System.out.println("result is:");
    System.out.print(result);
    
    
    sc.close();
    
    }
}

```

# 4. 参考题解
[题解](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-bai-liao-9983de-javayong-hu-by-reedfan/)
本人只是学习者，做完题记录做题过程，有助于理解。本题的解决思路和出现的图片，参考于链接中的题解，对本题解原作者表示感谢。



