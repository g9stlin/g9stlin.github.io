---
title: LeetCode32最长有效括号
date: 2020-2-15
permalink: /posts/2020/2/15/blog-post/ 
tags: 
- 算法笔记
- LeetCode
- 数据结构
renderNumberedHeading: true
grammar_cjkRuby: true
---


# 1. 题目
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例1：**
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"

**示例 2:**
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

#  2. 题解
参照题解地址：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/

遇到括号问题，上次在 **LeetCode 20. 有效括号** 遇到过，当时的方法是利用栈来解决，本题也是利用栈来求解。
我们对字符串进行遍历，具体步骤如下：
1. 检测到左括号 " ( "，将它的下标压入栈；
2. 检测到右括号 " ) "，
2.1  首先弹出栈顶元素，然后将当前右括号的下标与出栈操作之后的栈顶元素求差，即： **有效括号长度 = 当前右括号的下标 - 与之匹配的左括号的左边字符的下标**；
2.2  如果出栈操作后，栈为空，则将当前右括号的下标压入栈，进行下一次检测。
![](https://img-blog.csdnimg.cn/20200215161258820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20200215161324399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20200215161552467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200215161616408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200215161635340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200215161653594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20200215161710188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200215161726973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/20200215161741988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)![](https://img-blog.csdnimg.cn/20200215161754808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
![](https://img-blog.csdnimg.cn/2020021516180827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70)
#  3. Java实现

``` java
import java.util.Scanner;
import java.util.Stack;

class Solution01 {
	public int longestValidParentheses(String s) {
		int maxres=0;//初始化最大长度的变量
		Stack<Integer> stack = new Stack<>();
		stack.push(-1);//先将-1压入栈，以便下一次计算有效长度
		for(int i=0;i<s.length();i++) {//遍历字符串的索引
			if(s.charAt(i) == '(') {//如果遇到左括号，则将其的下标压入栈
				stack.push(i);
			}else {//否则就是遇到了右括号 
				stack.pop();//将上一个括号的下标出栈
				if(stack.empty()) {//如果出栈后，栈为空
					stack.push(i);//则将当前括号的下标压入栈，继续遍历下一个括号
				}else {//如果出栈后 栈不为空，则计算最大有效括号长度
					maxres=Math.max(maxres, i-stack.peek());//即为当前右括号的下标，减去其左括号左边的索引值(栈顶的内容) 也就是 i-stack.peek()
				}
			}
		}
		return maxres;
	}
	
	//test case
    public static void main(String[] args){
    Solution01 test=new Solution01();
    System.out.println("input String :");
    Scanner sc = new Scanner(System.in);
    String str = sc.next().toString();
    int result = test.longestValidParentheses(str);
    System.out.println("result is:");
    System.out.print(result);
    
    
    sc.close();
    
    }
}
```

# 4. 参考题解
[链接](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/)
本人只是学习者，做完题记录做题过程，有助于理解。本题的解决思路和出现的图片，参考于链接中的题解，对本题解原作者表示感谢。




