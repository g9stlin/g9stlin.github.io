---
title: 2020-2-14-LeetCode31下一个排列
date: 2020-2-14
permalink: /posts/2020/2/14/blog-post/ 
tags: 
- 算法笔记
- LeetCode
- 数据结构
renderNumberedHeading: true
grammar_cjkRuby: true
---

# 1. 题目
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> 1,2,3 → 1,3,2
> 3,2,1 → 1,2,3
> 1,1,5 → 1,5,1




# 2. 题解
参照题解地址：
https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/

首先，对于完全降序排列的序列，没有下一个更大的排列，只能为最小排列，即升序排列。我们需要从后往前找，排查相邻两个数字是否为降序排列 即 a[i-1] >= a[i]，如果不为降序排列 即a[i-1] < a[i]，则存在下一个更大排列，需要对从i-1位置之后（包括本位）的序列进行重新排列。

那么如何才能产生下一个更大的序列呢？
1. 将数字 a[i-1]替换为位于其右侧区域的数字中比它更大的数字，例如 a[j]。a[j]需要从后往前搜索。
![Alt](https://img-blog.csdnimg.cn/20200214231808913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqd3N0ZXZlbg==,size_16,color_FFFFFF,t_70#pic_center)
2. 交换过后，暂时还不满足要求，需要调整 a[i-1]右边的数字（不包括本位）来形成最小的排列。 因此，我们需要将这部分数字按升序排列，以获得最小的排列。

由于step 1交换后，这部分序列已为当前最大降序序列（a[i-1]右侧，除去a[i-1]），所以我们需要把他们变为最小序列。办法是反转 a[i-1]之后的数字，以获得下一个最小的字典排列。如 654321，6-1交换，5-2交换，4-3交换，将这部分序列变成最小序列。
![Alt](https://img-blog.csdnimg.cn/20200214232718811.gif#pic_center)
# 3. Java实现

```java
import java.util.Scanner;

class Solution01 {
	
	public void nextPermutation(int[] nums) {
		//先从后往前逐对查找相邻两个数是否为降序排列 即a[i]<=a[i-1],如果不是，则需要调整
		int i=nums.length-2;//索引i指向倒数第二个数
		while(i>=0 && nums[i+1]<=nums[i]){//如果从后往前相邻两数为降序，则指针往前移动
			i--;//直到移到最左端结束循环，或者如果检测到有升序排列的数对，则结束循环，记录较小数所在的位置i
		}
		if(i>=0){//如果在某个地方存在较小数 使得不能成为相邻数字的降序 需要进行调整
			int j=nums.length-1;//从数组末端开始查找比当前较小数a[i]更大的数，索引j指向数组末端
			while(j>=0 && nums[j]<=nums[i]){//找到a[j]>a[i],记录a[j]的位置
				j--;
			}
			swap(nums,i,j);//交换a[i]和a[j]位置
		}
		reverse(nums,i+1);//调整完，将剩余的数字序列由降序颠倒为升序 即对应位交换
		
	}
	
	private void swap(int[] nums,int i,int j){//数组的指定位置两元素交换位置
		int temp=nums[i];
		 nums[i]=nums[j];
		 nums[j]=temp;
		
	}
	
	private void reverse(int[] nums,int start){//将数组的对应位置互相交换，首位交换
		int i=start,j=nums.length-1;
		while(i<j){
			swap(nums,i,j);
			i++;
			j--;
		}
	}
	
	//test case
    public static void main(String[] args){
    Solution01 test=new Solution01();
    System.out.println("input array :");
    Scanner sc = new Scanner(System.in);
    String str = sc.next().toString();
    String[] arr  = str.split(",");
    int[] c=new int[arr.length];
    for(int j = 0; j<c.length;j++) {
    	c[j]=Integer.parseInt(arr[j]);
    }
    
    test.nextPermutation(c);;
    System.out.println("result is:");
    for(int i=0;i<c.length;i++){
        System.out.print(c[i]+" ");
    }
    
    
    sc.close();
    
    }
}
```
# 4. 参考题解
 [链接](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode/)
 
 本人也只是学习者，本题的思路根据LeetCode题解加以理解完成的，对本题原作者表示感谢。

